

NEED TO UPDATED UPDATEDdATE FOR RULES AND MAP in post load

pass:
done with server refactor to base class, now go to UI and refactor all services to a RestBaseClass,
so will hafe the same thing: empty subclass with resused code, but can override at will



mon:
* file upload/download capbility

project todo
* only latest rule can be updated, but all rules should be visible?

///// framework TODO:
* checkout a concurrency error in UI
* database update strategy: version in db, load all files in sequence and run with mongo using childProcess or so, so a list of directories, then sort by number, then compare db version and run those over that number in sequence

* controller/repo/service base class? these 3 are exactly the same over and over, could push that all to a base calss, the subclass could override for something special?
* need a db update script that runs 'after' data load, so scrpt to create collections .. then load data, then add timestamps. Also, need to add rule fiscal mo/yr? or just use the updated date? i.e. how to separate the rules into mo/yr buckets? Virtual property in mongoose?, and need to duplicate rules under different mo/yr to test things out, do that in an update script too
* concurrency only works if updatedDate. Need to use a timestamp? sent and email to ram/arindam on it
* need a back link for add/edit pages to get back to list
* need a object dirty check and a warning dialog if they try to cancel or leave and the data has been changed
* concurrency: need a code for this so you can put up the right message when they try to delete something (that still exists) but has been updated. Anytime they delete or update and don't have the latest... they need to get a message: your data needs to be refreshed, not: item not found, as it's there and they're trying to delet it, just that the rule needs to be: if it's changed, then don't update or delete, make them look at the new version as someone else has been messing with it.
* move rule add/update metadata to a modules.json data doc, i.e. in db, and don't add a schema for it, just have it as "string", so module: {id, name, metadata}, then we can update metadata on the fly, but need to wrap well in unit tests so if they change something that will break the ui, we catch it. Say they add one to one array, and it uses that to access another array they didnt' add to and that crashes the code. me's rule add/edit formChange is what needst to be tested well for breakage.
* rule create/edit should be same page
* rule create/update needs to use rule object, not properties on comp
* create graphql classes in ui
* create graphql input classes in qi? Const can enforce required then
* go with ruleAddInput, ruleUpdateInput, or look at their trick with the id on put, then add createdBy/Date to that list
* ruleInput doesnt hahve any required fields
* why is she doing the refetchQueries?? what is that again? graphql thing as it's hitting the server with it
* lazy load modules
* bring in your styles directory if appropriate
* breakcrumb code to: data in routing with store observable and routing done handler that pubs to store with breadcrumb subing to that obs.
* review cui comps to see where they get their css from. Internally (
* mongoose schemas don't recognize dates. Ok or not? Only a problem is you need to mess with a date in repo?
* dump the app comp routing event stuff
* css >> scss
* USE ME'S FIELD NAMES FROM NG CODE FOR DB
* add: allocationInput shouldn't require createdBy/date, updatedby/date, that's the api's job to fill in for add
* update: should have created by/date, but updated isn't required (htough might be there)

database
change csv file headers to what's in the code (camel case) and create a doc that maps between the two:
old line followed by new line with titlte line: allocation_rules, RULE_NAME >> name



